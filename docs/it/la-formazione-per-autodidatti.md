---
layout: default
title: La formazione per autodidatti
nav_order: 19
---

<!-- prettier-ignore-start -->
# La formazione per autodidatti
{: .no_toc }

- TOC
{:toc}

<!-- prettier-ignore-end -->

Impadronirsi dei fondamenti di informatica e programmazione, sia per farne una professione che per scopi puramente hobbistici, è certamente un'impresa stimolante ed eccitante, tanto per i risultati a cui può condurre, quanto per il puro piacere del _viaggio_ nella conoscenza che state intraprendendo.

Prima di proporvi un possibile itinerario di apprendimento, però, trovo utile e necessario porvi di fronte ad un esame di coscienza: più sinceramente ed onestamente risponderete a voi stessi, maggiore vantaggio trarrete dal quadro che le vostre risposte delineerà.

Un noto adagio recita _**chiunque può programmare, ma non chiunque può diventare developer**_.
Sembra una contraddizione in termini ma in realtà questa frase nasconde una grande verità: al di là di qualunque eccitazione iniziale per la faccenda, è utilissimo essere onesti con se stessi e capire - magari facendosi aiutare da chi può valutare con obiettività e cognizione di causa la vostra predisposizione -, se effettivamente la programmazione può essere per voi una strada serena o se è destinata a trasformarsi in una fatica improba, costellata solo di frustrazioni.

Contrariamente a quello che vi aspettereste di sentirvi dire in questo libro, programmare è un mestiere molto più **creativo** e molto meno tecnico di quanto si pensi.
Guardare il monitor e vedere schermate di codice che scorrono sotto i vostri occhi non è sufficiente; è necessario che quel codice lo vediate con _gli occhi della mente_ e che nella vostra testa si delinei subito il quadro complessivo in cui quel codice si innesta.
Meglio ancora: dovreste poter guardare il codice sempre in questo modo, e dovreste essere in grado di immaginare scenari diversi, dovreste sentire una voce interna che vi dice: _Ah, sì, questo codice fa questa cosa ma si può fare meglio/più rapidamente/con meno dispendio di energie e risorse se facessi in quest'altro modo..._
In due parole: se non avete una _inclinazione naturalmente_ verso la materia, potete farcela lo stesso, ma la vostra vita professionale sarà una fatica perenne.
Vi conviene? Solo perché avete in mente un'immagine _romantica_ di chi programma e del suo mestiere, magari tratta dai numerosi film che potreste aver visto?
Non che il mestiere in sé sia gelido, tutt'altro: a volte l'eleganza di una soluzione ad un problema, può commuovere fino alle lacrime e non per densità semantica condensata in due righe di codice ma per l'idea che dietro quelle due righe di codice c'è stato un guizzo creativo, subito accompagnato da finezza nella tecnica, ma pur sempre prodotto da un essere umano: questo, è il bello ed il romantico di questo mestiere.
Inutile dire che di sola romanticheria non si vive e che spesso e volentieri, anche utilizzando gli strumenti più appropriati e più adatti per sollevarci da lavori ripetitivi, la vita quotidiana da developer non è sistematicamente soggetta a scariche di adrenalina.
Anzi, dietro un lavoro ben fatto, di norma, c'è tanta, tanta _falegnameria_.
Insomma, se alle domande _Ho una reale predisposizione?_ e _Riuscirò ad accettare che il percorso di istruzione che sto per intraprendere non sarà tutto un tappeto di petali di rose?_ avete risposto con un Sì netto e sicuro, siete già a metà dell'opera, congratulazioni!

Chiunque può programmare, allora?
In teoria, nel momento stesso in cui pensate _Ah, ora vado a mettere su la caffettiera_, voi tutti avete in mente - senza rendervene conto -, un piano precisissimo che prevede i seguenti passi:

1. Prendere la caffettiera
2. Riempire d'acqua la caldaia fino al segno
3. Inserire il filtro
4. Svuotare dell'eccesso di acqua
5. Riempire il filtro con il caffè senza pressarlo
6. Ecc... fino alla tazzina fumante

Non tutti i problemi si risolvono altrettanto facilmente ma spesso, più che la competenza tecnica, quello che fa un'enorme differenza è l'approccio al problema e - di riflesso -, anche alla sua soluzione.
Esempio banale ma calzante: una volta mi è capitato di avere a che fare con un'applicazione discretamente complessa nella quale, ad un certo punto del processo, avrei dovuto stabilire in un loop molto pesante se nel database dovevo effettuare un'operazione di inserimento o di aggiornamento dei dati.
Richiedendo la cosa molti controlli e volendola semplificare a tutti i costi, risolsi felicemente la faccenda inizializzando valori nelle tabelle all'apertura dell'applicazione.
E ciò fece in modo che avessi automaticamente (e gratis) solo operazioni di aggiornamento e, quindi, potei eliminare tutta una serie di controlli lunghi, complessi, farraginosi e forieri di errori.
Non è un esempio esaustivo, ma spero vi abbia suggerito un'idea migliore di quella che poche righe fa ho chiamato _creatività_.

Tra l'altro, l'esempio che vi ho appena fornito mette in luce che la programmazione, sia pure con una buona dose di creatività, richiede comunque ed in prima istanza un **approccio analitico ai problemi** e, a seguire, la conoscenza dei metodi/mezzi/strumenti con cui implementare una possibile soluzione (perché sì: _c'è sempre più di un modo per farlo_).
Fortunatamente, è possibile migliorare le proprie capacità analitiche attraverso un lungo periodo di esercitazione mentre per la creatività... o ce l'hai o non ce l'hai, punto.
Questo non vuol dire che chi programma eseguendo i suoi compiti in maniera canonica sia peggiore di una persona baciata dalla Musa della Creatività, ma è fuori discussione che quest'ultima avrà una marcia in più.
Ora, zoomiamo sul nostro specifico interesse, l'auto-formazione: è ovvio che la discussione filosofica sin qui fatta si applica a tutti, autodidatti e/o persone che hanno seguito un corso di studi classico (università) ma per entrambi, la storia della creatività continua a valere.
Di contro, è anche vero che seguire un percorso universitario non ha mai fatto male a nessuno ed offre il vantaggio di frequentare un ambiente nel quale è possibile confrontarsi con altre persone con la nostra stessa passione ed interessi, mentre se siamo autodidatti, queste possibilità sono un po' più ridotte, ma non insuperabili.
Resta il fatto, che in generale sarete _soli_ davanti a libri, monitor, codice e... caffè!
Ad ogni modo, a volte è _meglio soli che male accompagnati_ e con la giusta motivazione e passione per la materia, anche lo studio e la sperimentazione in solitaria non vi peserà più di tanto.

Da non sottovalutare, nel 2023, che la pervasività e disponibilità H24 7/7 di una connessione ad internet è di grandissimo aiuto ad un autodidatta, perché le risorse che può reperire in rete, gratis o con poca spesa, sono praticamente sterminate e - soprattutto agli inizi -, costituiscono un validissimo aiuto alla comprensione di argomenti che tutto sono meno che romantici.
Superate le domande motivazionali, prima di mettervi all'opera, dovete porvi parecchie altre domande, stavolta di natura squisitamente più tecnica/tecnologica.

Il termine _programmare_ è un ombrello enorme che accoglie sotto di sé innumerevoli sfumature di codice e dunque, sapere con la miglior precisione possibile a quale tipo di programmazione volete dedicarvi, vi tornerà utilissimo per sfrondare l'inutile e farvi invece una lista utilissima degli strumenti dei quali dovreste impadronirvi.
Non esiste una sola forma di programmazione ma qualunque applicativo (a meno che non vogliate scrivere solo script bash di amministrazione), di solito ha una _interfaccia utente_, in genere ma non necessariamente anche grafica che è detta _**Frontend**_ e tutto quello che succede quando un utente clicca su un pulsante del Frontend; questa parte, è nota come "**Backend**" o retrobottega.
Il Backend non è visibile all'utente e quindi non viene applaudito e lodato come i Frontend ma state certi che se avrete fatto un buon lavoro - che ne so? -, su un sistema bancario, l'utente finale vi sarà grato per avergli ad esempio evidenziato in maniera chiara e precisa problemi o anche opportunità legate al suo conto corrente.

Fatta questa prima scelta, dovete preoccuparvi di capire su quali tecnologie volete formarvi e prepararvi.
Un mio consiglio, opinione del tutto personale, è: evitate come la peste di gettarvi a corpo morto sui numerosi _framework_ in circolazione.
Che siano framework frontend o backend, è essenziale che prima di utilizzarli vi impadroniate di ciò che c'è alla loro base.
Questo approccio, non solo vi permetterà di comprendere le cose a basso livello, ma, in seguito, quando vi avvicinerete ad un qualunque framework, vi consentirà di comprenderne molto più rapidamente e facilmente i suoi _internals_, che sono invariabilmente basati proprio su... le basi.
Non posso suggerirvi tecnologie o linguaggi specifici ma posso dirvi che in generale, è vero che dovreste sentirvi molto _falegnami_ e sapere quale è l'attrezzo, lo strumento, l'utensile più idoneo ad assolvere ad una determinata funzione.
E dato che le funzioni possono essere molte, questo spiega anche il proliferare dei framework e la necessità di sapere almeno _che cosa fanno_, per quale compito meglio si prestano.
Diversamente, sarebbe come andare a casa dell'anziana signora per ripararle una tapparella ed accorgersi solo una volta sulla scala, che avremmo avuto bisogno di un cacciavite a croce oltre che di quello a lama piatta.
Il che significa scendere dalla scala, tornare in officina, prendere il cacciavite mancante e quindi tornare sulla scala; una perdita di tempo ed energie inutile, vi pare?
